package cqrs

import (
	"github.com/ThreeDotsLabs/watermill"
	"github.com/pkg/errors"
	"github.com/satioO/scheduler/scheduler/cqrs/commands"
	"github.com/satioO/scheduler/scheduler/cqrs/marshaler"
	"github.com/satioO/scheduler/scheduler/cqrs/message"
)

type AppConfig struct {
	// It allows you to use topic per command or one topic for every command. [todo - add to doc]
	GenerateCommandsTopic func(commandName string) string

	// CommandHandlers return command handlers which should be executed.
	CommandHandlers func(commandBus *commands.CommandBus) []commands.CommandsHandler

	// CommandsPublisher is Publisher used to publish commands.
	CommandsPublisher message.Publisher

	CommandEventMarshaler marshaler.CommandEventMarshaler

	// CommandsSubscriber is constructor for subscribers which will subscribe for messages.
	// It will be called for every command handler.
	// It allows you to create separated customized Subscriber for every command handler.
	CommandsSubscriberConstructor commands.CommandsSubscriberConstructor

	// Router is a router, which will be used to handle events and commands.
	// Router handlers will be automatically generated by AddHandlersToRouter of Command and Event handlers.
	Router *message.Router

	Logger watermill.LoggerAdapter
}

type App struct {
	commandsTopic         func(commandName string) string
	commandBus            *commands.CommandBus
	commandEventMarshaler marshaler.CommandEventMarshaler
}

func (f App) CommandBus() *commands.CommandBus {
	return f.commandBus
}

func (f App) CommandEventMarshaler() marshaler.CommandEventMarshaler {
	return f.commandEventMarshaler
}

func NewApp(config *AppConfig) (*App, error) {
	commandBus, err := commands.NewCommandBus(
		config.CommandsPublisher,
		config.GenerateCommandsTopic,
		config.CommandEventMarshaler,
	)

	if err != nil {
		panic(err)
	}

	app := &App{
		commandsTopic:         config.GenerateCommandsTopic,
		commandBus:            commandBus,
		commandEventMarshaler: config.CommandEventMarshaler,
	}

	commandProcessor, err := commands.NewCommandProcessor(
		config.CommandHandlers(app.commandBus),
		config.GenerateCommandsTopic,
		config.CommandsSubscriberConstructor,
		config.CommandEventMarshaler,
		config.Logger,
	)
	if err != nil {
		return nil, errors.Wrap(err, "cannot create command processor")
	}

	if err := commandProcessor.AddHandlersToRouter(config.Router); err != nil {
		return nil, err
	}

	return app, nil
}
